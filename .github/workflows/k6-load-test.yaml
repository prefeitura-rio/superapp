name: K6 Load Test (K8s)

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: "Target URL to test"
        required: true
        default: "https://staging.app.dados.rio"
        type: string
      peak_vus:
        description: "Peak virtual users (VUs)"
        required: true
        default: "100"
        type: string
      ramp_up_minutes:
        description: "Ramp up time (minutes)"
        required: true
        default: "2"
        type: string
      sustained_minutes:
        description: "Sustained load time (minutes)"
        required: true
        default: "5"
        type: string
      ramp_down_minutes:
        description: "Ramp down time (minutes)"
        required: true
        default: "2"
        type: string
      environment:
        description: "Environment (staging/production)"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

jobs:
  k6-load-test:
    name: Run K6 Load Test
    runs-on: ubuntu-latest
    environment: k6-${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS_JSON }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }}

      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: latest

      - name: Configure kubectl for GKE
        run: |
          gcloud container clusters get-credentials ${{ vars.GKE_CLUSTER_NAME }} \
            --region=${{ vars.GKE_CLUSTER_REGION }} \
            --project="${{ vars.GCP_PROJECT_ID }}"

      - name: Verify cluster connection
        run: kubectl cluster-info

      - name: Create k6 namespace if not exists
        run: kubectl create namespace ${{ vars.K6_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Generate test run ID
        id: test-run
        run: |
          TEST_RUN_ID="load-test-$(date +%Y%m%d-%H%M%S)"
          echo "test_run_id=$TEST_RUN_ID" >> $GITHUB_OUTPUT
          echo "ðŸ“ Test Run ID: $TEST_RUN_ID"

      - name: Create ConfigMap with k6 test scripts
        run: |
          kubectl create configmap k6-scripts-${{ steps.test-run.outputs.test_run_id }} \
            --from-file=config.js=load-tests/config.js \
            --from-file=main.js=load-tests/main.js \
            --from-file=service-seeker.js=load-tests/journeys/service-seeker.js \
            --from-file=course-explorer.js=load-tests/journeys/course-explorer.js \
            --from-file=browser.js=load-tests/journeys/browser.js \
            --from-file=searcher.js=load-tests/journeys/searcher.js \
            --namespace=${{ vars.K6_NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Calculate parallelism
        id: parallelism
        run: |
          # Calculate parallelism with max 250 VUs per pod
          # Formula: ceil(peak_vus / 250), capped at 50 pods max
          PEAK_VUS=${{ inputs.peak_vus }}
          PARALLELISM=$(( (PEAK_VUS + 249) / 250 ))

          # Ensure at least 1 pod, max 50 pods
          if [ $PARALLELISM -lt 1 ]; then
            PARALLELISM=1
          elif [ $PARALLELISM -gt 50 ]; then
            PARALLELISM=50
          fi

          echo "parallelism=$PARALLELISM" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Calculated parallelism: $PARALLELISM pods for $PEAK_VUS VUs (~$(( PEAK_VUS / PARALLELISM )) VUs per pod)"

      - name: Create k6 TestRun CRD
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: k6.io/v1alpha1
          kind: TestRun
          metadata:
            name: ${{ steps.test-run.outputs.test_run_id }}
            namespace: ${{ vars.K6_NAMESPACE }}
          spec:
            parallelism: ${{ steps.parallelism.outputs.parallelism }}
            script:
              configMap:
                name: k6-scripts-${{ steps.test-run.outputs.test_run_id }}
                file: main.js
            runner:
              image: grafana/k6:latest
              resources:
                requests:
                  cpu: 500m
                  memory: 512Mi
                limits:
                  cpu: 2000m
                  memory: 2Gi
              env:
                - name: K6_BASE_URL
                  value: "${{ inputs.target_url }}"
                - name: TEST_STAGES
                  value: |
                    [
                      { "duration": "${{ inputs.ramp_up_minutes }}m", "target": ${{ inputs.peak_vus }} },
                      { "duration": "${{ inputs.sustained_minutes }}m", "target": ${{ inputs.peak_vus }} },
                      { "duration": "${{ inputs.ramp_down_minutes }}m", "target": 0 }
                    ]
          EOF

      - name: Wait for test completion and collect logs
        timeout-minutes: 60
        run: |
          echo "â³ Waiting for test to complete..."
          mkdir -p test-results

          while true; do
            STATUS=$(kubectl get testrun ${{ steps.test-run.outputs.test_run_id }} \
              -n ${{ vars.K6_NAMESPACE }} \
              -o jsonpath='{.status.stage}' 2>/dev/null || echo "")

            echo "Status: $STATUS"

            if [ "$STATUS" = "finished" ] || [ "$STATUS" = "error" ]; then
              echo "âœ“ Test completed with status: $STATUS"
              break
            fi

            sleep 10
          done

          # Collect logs after test completion
          echo "ðŸ“Š Collecting logs from completed test..."
          PODS=$(kubectl get pods -n ${{ vars.K6_NAMESPACE }} \
            -l k6_cr=${{ steps.test-run.outputs.test_run_id }},runner=true \
            --sort-by=.metadata.creationTimestamp \
            -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

          if [ -n "$PODS" ]; then
            for POD in $PODS; do
              echo "  - Collecting logs from: $POD"
              kubectl logs $POD -n ${{ vars.K6_NAMESPACE }} --tail=-1 > test-results/${POD}.log 2>&1 || true
            done
            echo "âœ“ Collected logs from $( echo $PODS | wc -w ) pod(s)"
          else
            echo "âš ï¸ No pods found with label k6_cr=${{ steps.test-run.outputs.test_run_id }},runner=true"
          fi

          # Create a k6 summary from the logs
          echo "ðŸ“Š Extracting k6 summary from logs..."
          if ls test-results/*.log 1> /dev/null 2>&1; then
            # Find the log with the k6 summary (look for the checks or http_req_duration metrics)
            for LOG in test-results/*.log; do
              if grep -q "http_req_duration" "$LOG" 2>/dev/null; then
                echo "  Found k6 summary in: $(basename $LOG)"
                grep -A 50 "http_req_duration" "$LOG" > test-results/k6-summary.txt 2>/dev/null || true
                break
              fi
            done
          fi

          echo "âœ“ Collection complete"
          ls -lh test-results/ || true

      - name: Upload results to GCS
        if: always()
        run: |
          BUCKET="${{ vars.GCS_RESULTS_BUCKET }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          RESULTS_PATH="load-tests/${{ inputs.environment }}/${TIMESTAMP}-${{ steps.test-run.outputs.test_run_id }}"

          echo "ðŸ“¤ Uploading results to gs://${BUCKET}/${RESULTS_PATH}/"

          gsutil -m cp -r test-results/* "gs://${BUCKET}/${RESULTS_PATH}/" || true

          # Create a summary file with test metadata
          cat > test-results/metadata.json <<EOF
          {
            "test_run_id": "${{ steps.test-run.outputs.test_run_id }}",
            "timestamp": "${TIMESTAMP}",
            "environment": "${{ inputs.environment }}",
            "target_url": "${{ inputs.target_url }}",
            "peak_vus": ${{ inputs.peak_vus }},
            "ramp_up_minutes": ${{ inputs.ramp_up_minutes }},
            "sustained_minutes": ${{ inputs.sustained_minutes }},
            "ramp_down_minutes": ${{ inputs.ramp_down_minutes }},
            "github_run_id": "${{ github.run_id }}",
            "github_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF

          gsutil cp test-results/metadata.json "gs://${BUCKET}/${RESULTS_PATH}/metadata.json"

          echo "âœ“ Results uploaded to: gs://${BUCKET}/${RESULTS_PATH}/"
          echo "ðŸ“Š View results: https://console.cloud.google.com/storage/browser/${BUCKET}/${RESULTS_PATH}"

      - name: Generate summary
        if: always()
        run: |
          echo "## ðŸ“Š Load Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Run ID:** \`${{ steps.test-run.outputs.test_run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Target URL:** ${{ inputs.target_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Peak VUs:** ${{ inputs.peak_vus }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Ramp Up:** ${{ inputs.ramp_up_minutes }} minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Sustained:** ${{ inputs.sustained_minutes }} minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Ramp Down:** ${{ inputs.ramp_down_minutes }} minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Duration:** $(( ${{ inputs.ramp_up_minutes }} + ${{ inputs.sustained_minutes }} + ${{ inputs.ramp_down_minutes }} )) minutes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Results" >> $GITHUB_STEP_SUMMARY

          BUCKET="${{ vars.GCS_RESULTS_BUCKET }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          RESULTS_PATH="load-tests/${{ inputs.environment }}/${TIMESTAMP}-${{ steps.test-run.outputs.test_run_id }}"

          echo "ðŸ“¦ Results stored at: \`gs://${BUCKET}/${RESULTS_PATH}/\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View in GCS Console: https://console.cloud.google.com/storage/browser/${BUCKET}/${RESULTS_PATH}" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup test resources
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up test resources..."

          kubectl delete testrun ${{ steps.test-run.outputs.test_run_id }} \
            -n ${{ vars.K6_NAMESPACE }} --ignore-not-found=true

          kubectl delete configmap k6-scripts-${{ steps.test-run.outputs.test_run_id }} \
            -n ${{ vars.K6_NAMESPACE }} --ignore-not-found=true

          echo "âœ“ Cleanup complete"
